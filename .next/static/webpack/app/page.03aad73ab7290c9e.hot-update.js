"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/use-time-tracker.ts":
/*!***************************************!*\
  !*** ./src/hooks/use-time-tracker.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTimeTracker: () => (/* binding */ useTimeTracker)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* eslint-disable react-hooks/set-state-in-effect */ /* __next_internal_client_entry_do_not_use__ useTimeTracker auto */ \nconst DEFAULT_ACTIVITIES = [];\nfunction useTimeTracker() {\n    const [activities, setActivities] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [activeActivity, setActiveActivity] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [sessionHistory, setSessionHistory] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [sessionStartTime, setSessionStartTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [dailyTodos, setDailyTodos] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [todoCompletions, setTodoCompletions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const intervalRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Load data from localStorage on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useTimeTracker.useEffect\": ()=>{\n            const savedActivities = localStorage.getItem('activities');\n            const savedHistory = localStorage.getItem('sessionHistory');\n            const savedDailyTodos = localStorage.getItem('dailyTodos');\n            const savedTodoCompletions = localStorage.getItem('todoCompletions');\n            if (savedActivities) {\n                setActivities(JSON.parse(savedActivities));\n            } else {\n                // Initialize with default activities\n                const defaultActivities = DEFAULT_ACTIVITIES.map({\n                    \"useTimeTracker.useEffect.defaultActivities\": (name)=>({\n                            name,\n                            totalSeconds: 0\n                        })\n                }[\"useTimeTracker.useEffect.defaultActivities\"]);\n                setActivities(defaultActivities);\n            }\n            if (savedHistory) {\n                const parsedHistory = JSON.parse(savedHistory);\n                // Convert date strings back to Date objects\n                const historyWithDates = parsedHistory.map({\n                    \"useTimeTracker.useEffect.historyWithDates\": (session)=>({\n                            ...session,\n                            startTime: new Date(session.startTime),\n                            endTime: new Date(session.endTime)\n                        })\n                }[\"useTimeTracker.useEffect.historyWithDates\"]);\n                setSessionHistory(historyWithDates);\n            }\n            if (savedDailyTodos) {\n                setDailyTodos(JSON.parse(savedDailyTodos));\n            }\n            if (savedTodoCompletions) {\n                setTodoCompletions(JSON.parse(savedTodoCompletions));\n            }\n        }\n    }[\"useTimeTracker.useEffect\"], []);\n    // Save activities to localStorage whenever they change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useTimeTracker.useEffect\": ()=>{\n            if (activities.length > 0) {\n                localStorage.setItem('activities', JSON.stringify(activities));\n            }\n        }\n    }[\"useTimeTracker.useEffect\"], [\n        activities\n    ]);\n    // Save session history to localStorage whenever it changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useTimeTracker.useEffect\": ()=>{\n            if (sessionHistory.length > 0) {\n                localStorage.setItem('sessionHistory', JSON.stringify(sessionHistory));\n            }\n        }\n    }[\"useTimeTracker.useEffect\"], [\n        sessionHistory\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useTimeTracker.useEffect\": ()=>{\n            localStorage.setItem('dailyTodos', JSON.stringify(dailyTodos));\n        }\n    }[\"useTimeTracker.useEffect\"], [\n        dailyTodos\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useTimeTracker.useEffect\": ()=>{\n            localStorage.setItem('todoCompletions', JSON.stringify(todoCompletions));\n        }\n    }[\"useTimeTracker.useEffect\"], [\n        todoCompletions\n    ]);\n    // Timer effect\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useTimeTracker.useEffect\": ()=>{\n            if (activeActivity) {\n                intervalRef.current = setInterval({\n                    \"useTimeTracker.useEffect\": ()=>{\n                        setActivities({\n                            \"useTimeTracker.useEffect\": (prev)=>prev.map({\n                                    \"useTimeTracker.useEffect\": (activity)=>activity.name === activeActivity ? {\n                                            ...activity,\n                                            totalSeconds: activity.totalSeconds + 1\n                                        } : activity\n                                }[\"useTimeTracker.useEffect\"])\n                        }[\"useTimeTracker.useEffect\"]);\n                    }\n                }[\"useTimeTracker.useEffect\"], 1000);\n            } else {\n                if (intervalRef.current) {\n                    clearInterval(intervalRef.current);\n                    intervalRef.current = null;\n                }\n            }\n            return ({\n                \"useTimeTracker.useEffect\": ()=>{\n                    if (intervalRef.current) {\n                        clearInterval(intervalRef.current);\n                    }\n                }\n            })[\"useTimeTracker.useEffect\"];\n        }\n    }[\"useTimeTracker.useEffect\"], [\n        activeActivity\n    ]);\n    const addActivity = (name)=>{\n        if (activities.some((activity)=>activity.name === name)) {\n            alert('Activity already exists!');\n            return;\n        }\n        const newActivity = {\n            name,\n            totalSeconds: 0\n        };\n        setActivities((prev)=>[\n                ...prev,\n                newActivity\n            ]);\n    };\n    const startActivity = (name)=>{\n        const now = new Date();\n        // If there's an active activity, stop it and create a session\n        if (activeActivity && sessionStartTime) {\n            const session = {\n                activityName: activeActivity,\n                startTime: sessionStartTime,\n                endTime: now,\n                durationSeconds: Math.floor((now.getTime() - sessionStartTime.getTime()) / 1000)\n            };\n            setSessionHistory((prev)=>[\n                    session,\n                    ...prev\n                ]);\n        }\n        // If clicking the same activity, stop it\n        if (activeActivity === name) {\n            setActiveActivity(null);\n            setSessionStartTime(null);\n        } else {\n            // Start the new activity\n            setActiveActivity(name);\n            setSessionStartTime(now);\n        }\n    };\n    const stopActivity = ()=>{\n        if (activeActivity && sessionStartTime) {\n            const now = new Date();\n            const session = {\n                activityName: activeActivity,\n                startTime: sessionStartTime,\n                endTime: now,\n                durationSeconds: Math.floor((now.getTime() - sessionStartTime.getTime()) / 1000)\n            };\n            setSessionHistory((prev)=>[\n                    session,\n                    ...prev\n                ]);\n        }\n        setActiveActivity(null);\n        setSessionStartTime(null);\n    };\n    const addDailyTodo = (name)=>{\n        if (dailyTodos.some((todo)=>todo.name === name)) {\n            alert('Todo already exists!');\n            return;\n        }\n        const newTodo = {\n            id: \"todo-\".concat(Date.now()),\n            name\n        };\n        setDailyTodos((prev)=>[\n                ...prev,\n                newTodo\n            ]);\n    };\n    const toggleTodoCompletion = (todoId, date)=>{\n        setTodoCompletions((prev)=>{\n            const existing = prev.find((c)=>c.todoId === todoId && c.date === date);\n            if (existing) {\n                // Toggle existing completion\n                return prev.map((c)=>c.todoId === todoId && c.date === date ? {\n                        ...c,\n                        completed: !c.completed\n                    } : c);\n            } else {\n                // Add new completion\n                return [\n                    ...prev,\n                    {\n                        todoId,\n                        date,\n                        completed: true\n                    }\n                ];\n            }\n        });\n    };\n    const getTodoCompletion = (todoId, date)=>{\n        const completion = todoCompletions.find((c)=>c.todoId === todoId && c.date === date);\n        var _completion_completed;\n        return (_completion_completed = completion === null || completion === void 0 ? void 0 : completion.completed) !== null && _completion_completed !== void 0 ? _completion_completed : false;\n    };\n    return {\n        activities,\n        activeActivity,\n        sessionHistory,\n        dailyTodos,\n        todoCompletions,\n        addActivity,\n        startActivity,\n        stopActivity,\n        addDailyTodo,\n        toggleTodoCompletion,\n        getTodoCompletion\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2UtdGltZS10cmFja2VyLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGtEQUFrRCx1RUFJQztBQUVuRCxNQUFNRyxxQkFBK0IsRUFBRTtBQUVoQyxTQUFTQztJQUNkLE1BQU0sQ0FBQ0MsWUFBWUMsY0FBYyxHQUFHSiwrQ0FBUUEsQ0FBYSxFQUFFO0lBQzNELE1BQU0sQ0FBQ0ssZ0JBQWdCQyxrQkFBa0IsR0FBR04sK0NBQVFBLENBQWdCO0lBQ3BFLE1BQU0sQ0FBQ08sZ0JBQWdCQyxrQkFBa0IsR0FBR1IsK0NBQVFBLENBQVksRUFBRTtJQUNsRSxNQUFNLENBQUNTLGtCQUFrQkMsb0JBQW9CLEdBQUdWLCtDQUFRQSxDQUFjO0lBQ3RFLE1BQU0sQ0FBQ1csWUFBWUMsY0FBYyxHQUFHWiwrQ0FBUUEsQ0FBYyxFQUFFO0lBQzVELE1BQU0sQ0FBQ2EsaUJBQWlCQyxtQkFBbUIsR0FBR2QsK0NBQVFBLENBQXdCLEVBQUU7SUFDaEYsTUFBTWUsY0FBY2hCLDZDQUFNQSxDQUF3QjtJQUVsRCx1Q0FBdUM7SUFDdkNELGdEQUFTQTtvQ0FBQztZQUNSLE1BQU1rQixrQkFBa0JDLGFBQWFDLE9BQU8sQ0FBQztZQUM3QyxNQUFNQyxlQUFlRixhQUFhQyxPQUFPLENBQUM7WUFDMUMsTUFBTUUsa0JBQWtCSCxhQUFhQyxPQUFPLENBQUM7WUFDN0MsTUFBTUcsdUJBQXVCSixhQUFhQyxPQUFPLENBQUM7WUFFbEQsSUFBSUYsaUJBQWlCO2dCQUNuQlosY0FBY2tCLEtBQUtDLEtBQUssQ0FBQ1A7WUFDM0IsT0FBTztnQkFDTCxxQ0FBcUM7Z0JBQ3JDLE1BQU1RLG9CQUFvQnZCLG1CQUFtQndCLEdBQUc7a0VBQUMsQ0FBQ0MsT0FBVTs0QkFDMURBOzRCQUNBQyxjQUFjO3dCQUNoQjs7Z0JBQ0F2QixjQUFjb0I7WUFDaEI7WUFFQSxJQUFJTCxjQUFjO2dCQUNoQixNQUFNUyxnQkFBZ0JOLEtBQUtDLEtBQUssQ0FBQ0o7Z0JBQ2pDLDRDQUE0QztnQkFDNUMsTUFBTVUsbUJBQW1CRCxjQUFjSCxHQUFHO2lFQUFDLENBQUNLLFVBQWtCOzRCQUM1RCxHQUFHQSxPQUFPOzRCQUNWQyxXQUFXLElBQUlDLEtBQUtGLFFBQVFDLFNBQVM7NEJBQ3JDRSxTQUFTLElBQUlELEtBQUtGLFFBQVFHLE9BQU87d0JBQ25DOztnQkFDQXpCLGtCQUFrQnFCO1lBQ3BCO1lBRUEsSUFBSVQsaUJBQWlCO2dCQUNuQlIsY0FBY1UsS0FBS0MsS0FBSyxDQUFDSDtZQUMzQjtZQUVBLElBQUlDLHNCQUFzQjtnQkFDeEJQLG1CQUFtQlEsS0FBS0MsS0FBSyxDQUFDRjtZQUNoQztRQUNGO21DQUFHLEVBQUU7SUFFTCx1REFBdUQ7SUFDdkR2QixnREFBU0E7b0NBQUM7WUFDUixJQUFJSyxXQUFXK0IsTUFBTSxHQUFHLEdBQUc7Z0JBQ3pCakIsYUFBYWtCLE9BQU8sQ0FBQyxjQUFjYixLQUFLYyxTQUFTLENBQUNqQztZQUNwRDtRQUNGO21DQUFHO1FBQUNBO0tBQVc7SUFFZiwyREFBMkQ7SUFDM0RMLGdEQUFTQTtvQ0FBQztZQUNSLElBQUlTLGVBQWUyQixNQUFNLEdBQUcsR0FBRztnQkFDN0JqQixhQUFha0IsT0FBTyxDQUFDLGtCQUFrQmIsS0FBS2MsU0FBUyxDQUFDN0I7WUFDeEQ7UUFDRjttQ0FBRztRQUFDQTtLQUFlO0lBRW5CVCxnREFBU0E7b0NBQUM7WUFDUm1CLGFBQWFrQixPQUFPLENBQUMsY0FBY2IsS0FBS2MsU0FBUyxDQUFDekI7UUFDcEQ7bUNBQUc7UUFBQ0E7S0FBVztJQUVmYixnREFBU0E7b0NBQUM7WUFDUm1CLGFBQWFrQixPQUFPLENBQUMsbUJBQW1CYixLQUFLYyxTQUFTLENBQUN2QjtRQUN6RDttQ0FBRztRQUFDQTtLQUFnQjtJQUVwQixlQUFlO0lBQ2ZmLGdEQUFTQTtvQ0FBQztZQUNSLElBQUlPLGdCQUFnQjtnQkFDbEJVLFlBQVlzQixPQUFPLEdBQUdDO2dEQUFZO3dCQUNoQ2xDO3dEQUFjLENBQUNtQyxPQUNiQSxLQUFLZCxHQUFHO2dFQUFDLENBQUNlLFdBQ1JBLFNBQVNkLElBQUksS0FBS3JCLGlCQUFpQjs0Q0FBRSxHQUFHbUMsUUFBUTs0Q0FBRWIsY0FBY2EsU0FBU2IsWUFBWSxHQUFHO3dDQUFFLElBQUlhOzs7b0JBR3BHOytDQUFHO1lBQ0wsT0FBTztnQkFDTCxJQUFJekIsWUFBWXNCLE9BQU8sRUFBRTtvQkFDdkJJLGNBQWMxQixZQUFZc0IsT0FBTztvQkFDakN0QixZQUFZc0IsT0FBTyxHQUFHO2dCQUN4QjtZQUNGO1lBRUE7NENBQU87b0JBQ0wsSUFBSXRCLFlBQVlzQixPQUFPLEVBQUU7d0JBQ3ZCSSxjQUFjMUIsWUFBWXNCLE9BQU87b0JBQ25DO2dCQUNGOztRQUNGO21DQUFHO1FBQUNoQztLQUFlO0lBRW5CLE1BQU1xQyxjQUFjLENBQUNoQjtRQUNuQixJQUFJdkIsV0FBV3dDLElBQUksQ0FBQyxDQUFDSCxXQUFhQSxTQUFTZCxJQUFJLEtBQUtBLE9BQU87WUFDekRrQixNQUFNO1lBQ047UUFDRjtRQUVBLE1BQU1DLGNBQXdCO1lBQzVCbkI7WUFDQUMsY0FBYztRQUNoQjtRQUVBdkIsY0FBYyxDQUFDbUMsT0FBUzttQkFBSUE7Z0JBQU1NO2FBQVk7SUFDaEQ7SUFFQSxNQUFNQyxnQkFBZ0IsQ0FBQ3BCO1FBQ3JCLE1BQU1xQixNQUFNLElBQUlmO1FBRWhCLDhEQUE4RDtRQUM5RCxJQUFJM0Isa0JBQWtCSSxrQkFBa0I7WUFDdEMsTUFBTXFCLFVBQW1CO2dCQUN2QmtCLGNBQWMzQztnQkFDZDBCLFdBQVd0QjtnQkFDWHdCLFNBQVNjO2dCQUNURSxpQkFBaUJDLEtBQUtDLEtBQUssQ0FBQyxDQUFDSixJQUFJSyxPQUFPLEtBQUszQyxpQkFBaUIyQyxPQUFPLEVBQUMsSUFBSztZQUM3RTtZQUNBNUMsa0JBQWtCLENBQUMrQixPQUFTO29CQUFDVDt1QkFBWVM7aUJBQUs7UUFDaEQ7UUFFQSx5Q0FBeUM7UUFDekMsSUFBSWxDLG1CQUFtQnFCLE1BQU07WUFDM0JwQixrQkFBa0I7WUFDbEJJLG9CQUFvQjtRQUN0QixPQUFPO1lBQ0wseUJBQXlCO1lBQ3pCSixrQkFBa0JvQjtZQUNsQmhCLG9CQUFvQnFDO1FBQ3RCO0lBQ0Y7SUFFQSxNQUFNTSxlQUFlO1FBQ25CLElBQUloRCxrQkFBa0JJLGtCQUFrQjtZQUN0QyxNQUFNc0MsTUFBTSxJQUFJZjtZQUNoQixNQUFNRixVQUFtQjtnQkFDdkJrQixjQUFjM0M7Z0JBQ2QwQixXQUFXdEI7Z0JBQ1h3QixTQUFTYztnQkFDVEUsaUJBQWlCQyxLQUFLQyxLQUFLLENBQUMsQ0FBQ0osSUFBSUssT0FBTyxLQUFLM0MsaUJBQWlCMkMsT0FBTyxFQUFDLElBQUs7WUFDN0U7WUFDQTVDLGtCQUFrQixDQUFDK0IsT0FBUztvQkFBQ1Q7dUJBQVlTO2lCQUFLO1FBQ2hEO1FBRUFqQyxrQkFBa0I7UUFDbEJJLG9CQUFvQjtJQUN0QjtJQUVBLE1BQU00QyxlQUFlLENBQUM1QjtRQUNwQixJQUFJZixXQUFXZ0MsSUFBSSxDQUFDLENBQUNZLE9BQVNBLEtBQUs3QixJQUFJLEtBQUtBLE9BQU87WUFDakRrQixNQUFNO1lBQ047UUFDRjtRQUVBLE1BQU1ZLFVBQXFCO1lBQ3pCQyxJQUFJLFFBQW1CLE9BQVh6QixLQUFLZSxHQUFHO1lBQ3BCckI7UUFDRjtRQUVBZCxjQUFjLENBQUMyQixPQUFTO21CQUFJQTtnQkFBTWlCO2FBQVE7SUFDNUM7SUFFQSxNQUFNRSx1QkFBdUIsQ0FBQ0MsUUFBZ0JDO1FBQzVDOUMsbUJBQW1CLENBQUN5QjtZQUNsQixNQUFNc0IsV0FBV3RCLEtBQUt1QixJQUFJLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRUosTUFBTSxLQUFLQSxVQUFVSSxFQUFFSCxJQUFJLEtBQUtBO1lBRXBFLElBQUlDLFVBQVU7Z0JBQ1osNkJBQTZCO2dCQUM3QixPQUFPdEIsS0FBS2QsR0FBRyxDQUFDLENBQUNzQyxJQUFPQSxFQUFFSixNQUFNLEtBQUtBLFVBQVVJLEVBQUVILElBQUksS0FBS0EsT0FBTzt3QkFBRSxHQUFHRyxDQUFDO3dCQUFFQyxXQUFXLENBQUNELEVBQUVDLFNBQVM7b0JBQUMsSUFBSUQ7WUFDdkcsT0FBTztnQkFDTCxxQkFBcUI7Z0JBQ3JCLE9BQU87dUJBQUl4QjtvQkFBTTt3QkFBRW9CO3dCQUFRQzt3QkFBTUksV0FBVztvQkFBSztpQkFBRTtZQUNyRDtRQUNGO0lBQ0Y7SUFFQSxNQUFNQyxvQkFBb0IsQ0FBQ04sUUFBZ0JDO1FBQ3pDLE1BQU1NLGFBQWFyRCxnQkFBZ0JpRCxJQUFJLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRUosTUFBTSxLQUFLQSxVQUFVSSxFQUFFSCxJQUFJLEtBQUtBO1lBQzFFTTtRQUFQLE9BQU9BLENBQUFBLHdCQUFBQSx1QkFBQUEsaUNBQUFBLFdBQVlGLFNBQVMsY0FBckJFLG1DQUFBQSx3QkFBeUI7SUFDbEM7SUFFQSxPQUFPO1FBQ0wvRDtRQUNBRTtRQUNBRTtRQUNBSTtRQUNBRTtRQUNBNkI7UUFDQUk7UUFDQU87UUFDQUM7UUFDQUk7UUFDQU87SUFDRjtBQUNGIiwic291cmNlcyI6WyIvaG9tZS9sdWNhcy9sdWNhcy90aW1lLXRyYWNrZXIvc3JjL2hvb2tzL3VzZS10aW1lLXRyYWNrZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaG9va3Mvc2V0LXN0YXRlLWluLWVmZmVjdCAqL1xuJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB0eXBlIHsgQWN0aXZpdHksIERhaWx5VG9kbywgRGFpbHlUb2RvQ29tcGxldGlvbiwgU2Vzc2lvbiB9IGZyb20gJ0AvdHlwZXMvYWN0aXZpdHknXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcblxuY29uc3QgREVGQVVMVF9BQ1RJVklUSUVTOiBzdHJpbmdbXSA9IFtdXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VUaW1lVHJhY2tlcigpIHtcbiAgY29uc3QgW2FjdGl2aXRpZXMsIHNldEFjdGl2aXRpZXNdID0gdXNlU3RhdGU8QWN0aXZpdHlbXT4oW10pXG4gIGNvbnN0IFthY3RpdmVBY3Rpdml0eSwgc2V0QWN0aXZlQWN0aXZpdHldID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbClcbiAgY29uc3QgW3Nlc3Npb25IaXN0b3J5LCBzZXRTZXNzaW9uSGlzdG9yeV0gPSB1c2VTdGF0ZTxTZXNzaW9uW10+KFtdKVxuICBjb25zdCBbc2Vzc2lvblN0YXJ0VGltZSwgc2V0U2Vzc2lvblN0YXJ0VGltZV0gPSB1c2VTdGF0ZTxEYXRlIHwgbnVsbD4obnVsbClcbiAgY29uc3QgW2RhaWx5VG9kb3MsIHNldERhaWx5VG9kb3NdID0gdXNlU3RhdGU8RGFpbHlUb2RvW10+KFtdKVxuICBjb25zdCBbdG9kb0NvbXBsZXRpb25zLCBzZXRUb2RvQ29tcGxldGlvbnNdID0gdXNlU3RhdGU8RGFpbHlUb2RvQ29tcGxldGlvbltdPihbXSlcbiAgY29uc3QgaW50ZXJ2YWxSZWYgPSB1c2VSZWY8Tm9kZUpTLlRpbWVvdXQgfCBudWxsPihudWxsKVxuXG4gIC8vIExvYWQgZGF0YSBmcm9tIGxvY2FsU3RvcmFnZSBvbiBtb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHNhdmVkQWN0aXZpdGllcyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhY3Rpdml0aWVzJylcbiAgICBjb25zdCBzYXZlZEhpc3RvcnkgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnc2Vzc2lvbkhpc3RvcnknKVxuICAgIGNvbnN0IHNhdmVkRGFpbHlUb2RvcyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdkYWlseVRvZG9zJylcbiAgICBjb25zdCBzYXZlZFRvZG9Db21wbGV0aW9ucyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2RvQ29tcGxldGlvbnMnKVxuXG4gICAgaWYgKHNhdmVkQWN0aXZpdGllcykge1xuICAgICAgc2V0QWN0aXZpdGllcyhKU09OLnBhcnNlKHNhdmVkQWN0aXZpdGllcykpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEluaXRpYWxpemUgd2l0aCBkZWZhdWx0IGFjdGl2aXRpZXNcbiAgICAgIGNvbnN0IGRlZmF1bHRBY3Rpdml0aWVzID0gREVGQVVMVF9BQ1RJVklUSUVTLm1hcCgobmFtZSkgPT4gKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdG90YWxTZWNvbmRzOiAwLFxuICAgICAgfSkpXG4gICAgICBzZXRBY3Rpdml0aWVzKGRlZmF1bHRBY3Rpdml0aWVzKVxuICAgIH1cblxuICAgIGlmIChzYXZlZEhpc3RvcnkpIHtcbiAgICAgIGNvbnN0IHBhcnNlZEhpc3RvcnkgPSBKU09OLnBhcnNlKHNhdmVkSGlzdG9yeSlcbiAgICAgIC8vIENvbnZlcnQgZGF0ZSBzdHJpbmdzIGJhY2sgdG8gRGF0ZSBvYmplY3RzXG4gICAgICBjb25zdCBoaXN0b3J5V2l0aERhdGVzID0gcGFyc2VkSGlzdG9yeS5tYXAoKHNlc3Npb246IGFueSkgPT4gKHtcbiAgICAgICAgLi4uc2Vzc2lvbixcbiAgICAgICAgc3RhcnRUaW1lOiBuZXcgRGF0ZShzZXNzaW9uLnN0YXJ0VGltZSksXG4gICAgICAgIGVuZFRpbWU6IG5ldyBEYXRlKHNlc3Npb24uZW5kVGltZSksXG4gICAgICB9KSlcbiAgICAgIHNldFNlc3Npb25IaXN0b3J5KGhpc3RvcnlXaXRoRGF0ZXMpXG4gICAgfVxuXG4gICAgaWYgKHNhdmVkRGFpbHlUb2Rvcykge1xuICAgICAgc2V0RGFpbHlUb2RvcyhKU09OLnBhcnNlKHNhdmVkRGFpbHlUb2RvcykpXG4gICAgfVxuXG4gICAgaWYgKHNhdmVkVG9kb0NvbXBsZXRpb25zKSB7XG4gICAgICBzZXRUb2RvQ29tcGxldGlvbnMoSlNPTi5wYXJzZShzYXZlZFRvZG9Db21wbGV0aW9ucykpXG4gICAgfVxuICB9LCBbXSlcblxuICAvLyBTYXZlIGFjdGl2aXRpZXMgdG8gbG9jYWxTdG9yYWdlIHdoZW5ldmVyIHRoZXkgY2hhbmdlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGFjdGl2aXRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2FjdGl2aXRpZXMnLCBKU09OLnN0cmluZ2lmeShhY3Rpdml0aWVzKSlcbiAgICB9XG4gIH0sIFthY3Rpdml0aWVzXSlcblxuICAvLyBTYXZlIHNlc3Npb24gaGlzdG9yeSB0byBsb2NhbFN0b3JhZ2Ugd2hlbmV2ZXIgaXQgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzZXNzaW9uSGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnc2Vzc2lvbkhpc3RvcnknLCBKU09OLnN0cmluZ2lmeShzZXNzaW9uSGlzdG9yeSkpXG4gICAgfVxuICB9LCBbc2Vzc2lvbkhpc3RvcnldKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2RhaWx5VG9kb3MnLCBKU09OLnN0cmluZ2lmeShkYWlseVRvZG9zKSlcbiAgfSwgW2RhaWx5VG9kb3NdKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3RvZG9Db21wbGV0aW9ucycsIEpTT04uc3RyaW5naWZ5KHRvZG9Db21wbGV0aW9ucykpXG4gIH0sIFt0b2RvQ29tcGxldGlvbnNdKVxuXG4gIC8vIFRpbWVyIGVmZmVjdFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChhY3RpdmVBY3Rpdml0eSkge1xuICAgICAgaW50ZXJ2YWxSZWYuY3VycmVudCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgc2V0QWN0aXZpdGllcygocHJldikgPT5cbiAgICAgICAgICBwcmV2Lm1hcCgoYWN0aXZpdHkpID0+XG4gICAgICAgICAgICBhY3Rpdml0eS5uYW1lID09PSBhY3RpdmVBY3Rpdml0eSA/IHsgLi4uYWN0aXZpdHksIHRvdGFsU2Vjb25kczogYWN0aXZpdHkudG90YWxTZWNvbmRzICsgMSB9IDogYWN0aXZpdHksXG4gICAgICAgICAgKSxcbiAgICAgICAgKVxuICAgICAgfSwgMTAwMClcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGludGVydmFsUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbFJlZi5jdXJyZW50KVxuICAgICAgICBpbnRlcnZhbFJlZi5jdXJyZW50ID0gbnVsbFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoaW50ZXJ2YWxSZWYuY3VycmVudCkge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsUmVmLmN1cnJlbnQpXG4gICAgICB9XG4gICAgfVxuICB9LCBbYWN0aXZlQWN0aXZpdHldKVxuXG4gIGNvbnN0IGFkZEFjdGl2aXR5ID0gKG5hbWU6IHN0cmluZykgPT4ge1xuICAgIGlmIChhY3Rpdml0aWVzLnNvbWUoKGFjdGl2aXR5KSA9PiBhY3Rpdml0eS5uYW1lID09PSBuYW1lKSkge1xuICAgICAgYWxlcnQoJ0FjdGl2aXR5IGFscmVhZHkgZXhpc3RzIScpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBuZXdBY3Rpdml0eTogQWN0aXZpdHkgPSB7XG4gICAgICBuYW1lLFxuICAgICAgdG90YWxTZWNvbmRzOiAwLFxuICAgIH1cblxuICAgIHNldEFjdGl2aXRpZXMoKHByZXYpID0+IFsuLi5wcmV2LCBuZXdBY3Rpdml0eV0pXG4gIH1cblxuICBjb25zdCBzdGFydEFjdGl2aXR5ID0gKG5hbWU6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKClcblxuICAgIC8vIElmIHRoZXJlJ3MgYW4gYWN0aXZlIGFjdGl2aXR5LCBzdG9wIGl0IGFuZCBjcmVhdGUgYSBzZXNzaW9uXG4gICAgaWYgKGFjdGl2ZUFjdGl2aXR5ICYmIHNlc3Npb25TdGFydFRpbWUpIHtcbiAgICAgIGNvbnN0IHNlc3Npb246IFNlc3Npb24gPSB7XG4gICAgICAgIGFjdGl2aXR5TmFtZTogYWN0aXZlQWN0aXZpdHksXG4gICAgICAgIHN0YXJ0VGltZTogc2Vzc2lvblN0YXJ0VGltZSxcbiAgICAgICAgZW5kVGltZTogbm93LFxuICAgICAgICBkdXJhdGlvblNlY29uZHM6IE1hdGguZmxvb3IoKG5vdy5nZXRUaW1lKCkgLSBzZXNzaW9uU3RhcnRUaW1lLmdldFRpbWUoKSkgLyAxMDAwKSxcbiAgICAgIH1cbiAgICAgIHNldFNlc3Npb25IaXN0b3J5KChwcmV2KSA9PiBbc2Vzc2lvbiwgLi4ucHJldl0pXG4gICAgfVxuXG4gICAgLy8gSWYgY2xpY2tpbmcgdGhlIHNhbWUgYWN0aXZpdHksIHN0b3AgaXRcbiAgICBpZiAoYWN0aXZlQWN0aXZpdHkgPT09IG5hbWUpIHtcbiAgICAgIHNldEFjdGl2ZUFjdGl2aXR5KG51bGwpXG4gICAgICBzZXRTZXNzaW9uU3RhcnRUaW1lKG51bGwpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0YXJ0IHRoZSBuZXcgYWN0aXZpdHlcbiAgICAgIHNldEFjdGl2ZUFjdGl2aXR5KG5hbWUpXG4gICAgICBzZXRTZXNzaW9uU3RhcnRUaW1lKG5vdylcbiAgICB9XG4gIH1cblxuICBjb25zdCBzdG9wQWN0aXZpdHkgPSAoKSA9PiB7XG4gICAgaWYgKGFjdGl2ZUFjdGl2aXR5ICYmIHNlc3Npb25TdGFydFRpbWUpIHtcbiAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKClcbiAgICAgIGNvbnN0IHNlc3Npb246IFNlc3Npb24gPSB7XG4gICAgICAgIGFjdGl2aXR5TmFtZTogYWN0aXZlQWN0aXZpdHksXG4gICAgICAgIHN0YXJ0VGltZTogc2Vzc2lvblN0YXJ0VGltZSxcbiAgICAgICAgZW5kVGltZTogbm93LFxuICAgICAgICBkdXJhdGlvblNlY29uZHM6IE1hdGguZmxvb3IoKG5vdy5nZXRUaW1lKCkgLSBzZXNzaW9uU3RhcnRUaW1lLmdldFRpbWUoKSkgLyAxMDAwKSxcbiAgICAgIH1cbiAgICAgIHNldFNlc3Npb25IaXN0b3J5KChwcmV2KSA9PiBbc2Vzc2lvbiwgLi4ucHJldl0pXG4gICAgfVxuXG4gICAgc2V0QWN0aXZlQWN0aXZpdHkobnVsbClcbiAgICBzZXRTZXNzaW9uU3RhcnRUaW1lKG51bGwpXG4gIH1cblxuICBjb25zdCBhZGREYWlseVRvZG8gPSAobmFtZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKGRhaWx5VG9kb3Muc29tZSgodG9kbykgPT4gdG9kby5uYW1lID09PSBuYW1lKSkge1xuICAgICAgYWxlcnQoJ1RvZG8gYWxyZWFkeSBleGlzdHMhJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IG5ld1RvZG86IERhaWx5VG9kbyA9IHtcbiAgICAgIGlkOiBgdG9kby0ke0RhdGUubm93KCl9YCxcbiAgICAgIG5hbWUsXG4gICAgfVxuXG4gICAgc2V0RGFpbHlUb2RvcygocHJldikgPT4gWy4uLnByZXYsIG5ld1RvZG9dKVxuICB9XG5cbiAgY29uc3QgdG9nZ2xlVG9kb0NvbXBsZXRpb24gPSAodG9kb0lkOiBzdHJpbmcsIGRhdGU6IHN0cmluZykgPT4ge1xuICAgIHNldFRvZG9Db21wbGV0aW9ucygocHJldikgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBwcmV2LmZpbmQoKGMpID0+IGMudG9kb0lkID09PSB0b2RvSWQgJiYgYy5kYXRlID09PSBkYXRlKVxuXG4gICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgLy8gVG9nZ2xlIGV4aXN0aW5nIGNvbXBsZXRpb25cbiAgICAgICAgcmV0dXJuIHByZXYubWFwKChjKSA9PiAoYy50b2RvSWQgPT09IHRvZG9JZCAmJiBjLmRhdGUgPT09IGRhdGUgPyB7IC4uLmMsIGNvbXBsZXRlZDogIWMuY29tcGxldGVkIH0gOiBjKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFkZCBuZXcgY29tcGxldGlvblxuICAgICAgICByZXR1cm4gWy4uLnByZXYsIHsgdG9kb0lkLCBkYXRlLCBjb21wbGV0ZWQ6IHRydWUgfV1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgY29uc3QgZ2V0VG9kb0NvbXBsZXRpb24gPSAodG9kb0lkOiBzdHJpbmcsIGRhdGU6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgIGNvbnN0IGNvbXBsZXRpb24gPSB0b2RvQ29tcGxldGlvbnMuZmluZCgoYykgPT4gYy50b2RvSWQgPT09IHRvZG9JZCAmJiBjLmRhdGUgPT09IGRhdGUpXG4gICAgcmV0dXJuIGNvbXBsZXRpb24/LmNvbXBsZXRlZCA/PyBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhY3Rpdml0aWVzLFxuICAgIGFjdGl2ZUFjdGl2aXR5LFxuICAgIHNlc3Npb25IaXN0b3J5LFxuICAgIGRhaWx5VG9kb3MsXG4gICAgdG9kb0NvbXBsZXRpb25zLFxuICAgIGFkZEFjdGl2aXR5LFxuICAgIHN0YXJ0QWN0aXZpdHksXG4gICAgc3RvcEFjdGl2aXR5LFxuICAgIGFkZERhaWx5VG9kbyxcbiAgICB0b2dnbGVUb2RvQ29tcGxldGlvbixcbiAgICBnZXRUb2RvQ29tcGxldGlvbixcbiAgfVxufVxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiREVGQVVMVF9BQ1RJVklUSUVTIiwidXNlVGltZVRyYWNrZXIiLCJhY3Rpdml0aWVzIiwic2V0QWN0aXZpdGllcyIsImFjdGl2ZUFjdGl2aXR5Iiwic2V0QWN0aXZlQWN0aXZpdHkiLCJzZXNzaW9uSGlzdG9yeSIsInNldFNlc3Npb25IaXN0b3J5Iiwic2Vzc2lvblN0YXJ0VGltZSIsInNldFNlc3Npb25TdGFydFRpbWUiLCJkYWlseVRvZG9zIiwic2V0RGFpbHlUb2RvcyIsInRvZG9Db21wbGV0aW9ucyIsInNldFRvZG9Db21wbGV0aW9ucyIsImludGVydmFsUmVmIiwic2F2ZWRBY3Rpdml0aWVzIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInNhdmVkSGlzdG9yeSIsInNhdmVkRGFpbHlUb2RvcyIsInNhdmVkVG9kb0NvbXBsZXRpb25zIiwiSlNPTiIsInBhcnNlIiwiZGVmYXVsdEFjdGl2aXRpZXMiLCJtYXAiLCJuYW1lIiwidG90YWxTZWNvbmRzIiwicGFyc2VkSGlzdG9yeSIsImhpc3RvcnlXaXRoRGF0ZXMiLCJzZXNzaW9uIiwic3RhcnRUaW1lIiwiRGF0ZSIsImVuZFRpbWUiLCJsZW5ndGgiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiY3VycmVudCIsInNldEludGVydmFsIiwicHJldiIsImFjdGl2aXR5IiwiY2xlYXJJbnRlcnZhbCIsImFkZEFjdGl2aXR5Iiwic29tZSIsImFsZXJ0IiwibmV3QWN0aXZpdHkiLCJzdGFydEFjdGl2aXR5Iiwibm93IiwiYWN0aXZpdHlOYW1lIiwiZHVyYXRpb25TZWNvbmRzIiwiTWF0aCIsImZsb29yIiwiZ2V0VGltZSIsInN0b3BBY3Rpdml0eSIsImFkZERhaWx5VG9kbyIsInRvZG8iLCJuZXdUb2RvIiwiaWQiLCJ0b2dnbGVUb2RvQ29tcGxldGlvbiIsInRvZG9JZCIsImRhdGUiLCJleGlzdGluZyIsImZpbmQiLCJjIiwiY29tcGxldGVkIiwiZ2V0VG9kb0NvbXBsZXRpb24iLCJjb21wbGV0aW9uIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/use-time-tracker.ts\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/use-time-tracker.ts":
/*!***************************************!*\
  !*** ./src/hooks/use-time-tracker.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTimeTracker: () => (/* binding */ useTimeTracker)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* eslint-disable @typescript-eslint/no-explicit-any */ /* eslint-disable react-hooks/set-state-in-effect */ /* __next_internal_client_entry_do_not_use__ useTimeTracker auto */ \nconst DEFAULT_ACTIVITIES = [];\nfunction useTimeTracker() {\n    const [activities, setActivities] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [activeActivity, setActiveActivity] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [sessionHistory, setSessionHistory] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [sessionStartTime, setSessionStartTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [dailyTodos, setDailyTodos] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [todoCompletions, setTodoCompletions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const intervalRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Load data from localStorage on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useTimeTracker.useEffect\": ()=>{\n            const savedActivities = localStorage.getItem('activities');\n            const savedHistory = localStorage.getItem('sessionHistory');\n            const savedDailyTodos = localStorage.getItem('dailyTodos');\n            const savedTodoCompletions = localStorage.getItem('todoCompletions');\n            if (savedActivities) {\n                setActivities(JSON.parse(savedActivities));\n            } else {\n                // Initialize with default activities\n                const defaultActivities = DEFAULT_ACTIVITIES.map({\n                    \"useTimeTracker.useEffect.defaultActivities\": (name)=>({\n                            name,\n                            totalSeconds: 0\n                        })\n                }[\"useTimeTracker.useEffect.defaultActivities\"]);\n                setActivities(defaultActivities);\n            }\n            if (savedHistory) {\n                const parsedHistory = JSON.parse(savedHistory);\n                // Convert date strings back to Date objects\n                const historyWithDates = parsedHistory.map({\n                    \"useTimeTracker.useEffect.historyWithDates\": (session)=>({\n                            ...session,\n                            startTime: new Date(session.startTime),\n                            endTime: new Date(session.endTime)\n                        })\n                }[\"useTimeTracker.useEffect.historyWithDates\"]);\n                setSessionHistory(historyWithDates);\n            }\n            if (savedDailyTodos) {\n                setDailyTodos(JSON.parse(savedDailyTodos));\n            }\n            if (savedTodoCompletions) {\n                setTodoCompletions(JSON.parse(savedTodoCompletions));\n            }\n        }\n    }[\"useTimeTracker.useEffect\"], []);\n    // Save activities to localStorage whenever they change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useTimeTracker.useEffect\": ()=>{\n            if (activities.length > 0) {\n                localStorage.setItem('activities', JSON.stringify(activities));\n            }\n        }\n    }[\"useTimeTracker.useEffect\"], [\n        activities\n    ]);\n    // Save session history to localStorage whenever it changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useTimeTracker.useEffect\": ()=>{\n            if (sessionHistory.length > 0) {\n                localStorage.setItem('sessionHistory', JSON.stringify(sessionHistory));\n            }\n        }\n    }[\"useTimeTracker.useEffect\"], [\n        sessionHistory\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useTimeTracker.useEffect\": ()=>{\n            localStorage.setItem('dailyTodos', JSON.stringify(dailyTodos));\n        }\n    }[\"useTimeTracker.useEffect\"], [\n        dailyTodos\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useTimeTracker.useEffect\": ()=>{\n            localStorage.setItem('todoCompletions', JSON.stringify(todoCompletions));\n        }\n    }[\"useTimeTracker.useEffect\"], [\n        todoCompletions\n    ]);\n    // Timer effect\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useTimeTracker.useEffect\": ()=>{\n            if (activeActivity) {\n                intervalRef.current = setInterval({\n                    \"useTimeTracker.useEffect\": ()=>{\n                        setActivities({\n                            \"useTimeTracker.useEffect\": (prev)=>prev.map({\n                                    \"useTimeTracker.useEffect\": (activity)=>activity.name === activeActivity ? {\n                                            ...activity,\n                                            totalSeconds: activity.totalSeconds + 1\n                                        } : activity\n                                }[\"useTimeTracker.useEffect\"])\n                        }[\"useTimeTracker.useEffect\"]);\n                    }\n                }[\"useTimeTracker.useEffect\"], 1000);\n            } else {\n                if (intervalRef.current) {\n                    clearInterval(intervalRef.current);\n                    intervalRef.current = null;\n                }\n            }\n            return ({\n                \"useTimeTracker.useEffect\": ()=>{\n                    if (intervalRef.current) {\n                        clearInterval(intervalRef.current);\n                    }\n                }\n            })[\"useTimeTracker.useEffect\"];\n        }\n    }[\"useTimeTracker.useEffect\"], [\n        activeActivity\n    ]);\n    const addActivity = (name)=>{\n        if (activities.some((activity)=>activity.name === name)) {\n            alert('Activity already exists!');\n            return;\n        }\n        const newActivity = {\n            name,\n            totalSeconds: 0\n        };\n        setActivities((prev)=>[\n                ...prev,\n                newActivity\n            ]);\n    };\n    const startActivity = (name)=>{\n        const now = new Date();\n        // If there's an active activity, stop it and create a session\n        if (activeActivity && sessionStartTime) {\n            const session = {\n                activityName: activeActivity,\n                startTime: sessionStartTime,\n                endTime: now,\n                durationSeconds: Math.floor((now.getTime() - sessionStartTime.getTime()) / 1000)\n            };\n            setSessionHistory((prev)=>[\n                    session,\n                    ...prev\n                ]);\n        }\n        // If clicking the same activity, stop it\n        if (activeActivity === name) {\n            setActiveActivity(null);\n            setSessionStartTime(null);\n        } else {\n            // Start the new activity\n            setActiveActivity(name);\n            setSessionStartTime(now);\n        }\n    };\n    const stopActivity = ()=>{\n        if (activeActivity && sessionStartTime) {\n            const now = new Date();\n            const session = {\n                activityName: activeActivity,\n                startTime: sessionStartTime,\n                endTime: now,\n                durationSeconds: Math.floor((now.getTime() - sessionStartTime.getTime()) / 1000)\n            };\n            setSessionHistory((prev)=>[\n                    session,\n                    ...prev\n                ]);\n        }\n        setActiveActivity(null);\n        setSessionStartTime(null);\n    };\n    const addDailyTodo = (name)=>{\n        if (dailyTodos.some((todo)=>todo.name === name)) {\n            alert('Todo already exists!');\n            return;\n        }\n        const newTodo = {\n            id: \"todo-\".concat(Date.now()),\n            name\n        };\n        setDailyTodos((prev)=>[\n                ...prev,\n                newTodo\n            ]);\n    };\n    const toggleTodoCompletion = (todoId, date)=>{\n        setTodoCompletions((prev)=>{\n            const existing = prev.find((c)=>c.todoId === todoId && c.date === date);\n            if (existing) {\n                // Toggle existing completion\n                return prev.map((c)=>c.todoId === todoId && c.date === date ? {\n                        ...c,\n                        completed: !c.completed\n                    } : c);\n            } else {\n                // Add new completion\n                return [\n                    ...prev,\n                    {\n                        todoId,\n                        date,\n                        completed: true\n                    }\n                ];\n            }\n        });\n    };\n    const getTodoCompletion = (todoId, date)=>{\n        const completion = todoCompletions.find((c)=>c.todoId === todoId && c.date === date);\n        var _completion_completed;\n        return (_completion_completed = completion === null || completion === void 0 ? void 0 : completion.completed) !== null && _completion_completed !== void 0 ? _completion_completed : false;\n    };\n    return {\n        activities,\n        activeActivity,\n        sessionHistory,\n        dailyTodos,\n        todoCompletions,\n        addActivity,\n        startActivity,\n        stopActivity,\n        addDailyTodo,\n        toggleTodoCompletion,\n        getTodoCompletion\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2UtdGltZS10cmFja2VyLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHFEQUFxRCxHQUNyRCxrREFBa0QsdUVBSUM7QUFFbkQsTUFBTUcscUJBQStCLEVBQUU7QUFFaEMsU0FBU0M7SUFDZCxNQUFNLENBQUNDLFlBQVlDLGNBQWMsR0FBR0osK0NBQVFBLENBQWEsRUFBRTtJQUMzRCxNQUFNLENBQUNLLGdCQUFnQkMsa0JBQWtCLEdBQUdOLCtDQUFRQSxDQUFnQjtJQUNwRSxNQUFNLENBQUNPLGdCQUFnQkMsa0JBQWtCLEdBQUdSLCtDQUFRQSxDQUFZLEVBQUU7SUFDbEUsTUFBTSxDQUFDUyxrQkFBa0JDLG9CQUFvQixHQUFHViwrQ0FBUUEsQ0FBYztJQUN0RSxNQUFNLENBQUNXLFlBQVlDLGNBQWMsR0FBR1osK0NBQVFBLENBQWMsRUFBRTtJQUM1RCxNQUFNLENBQUNhLGlCQUFpQkMsbUJBQW1CLEdBQUdkLCtDQUFRQSxDQUF3QixFQUFFO0lBQ2hGLE1BQU1lLGNBQWNoQiw2Q0FBTUEsQ0FBd0I7SUFFbEQsdUNBQXVDO0lBQ3ZDRCxnREFBU0E7b0NBQUM7WUFDUixNQUFNa0Isa0JBQWtCQyxhQUFhQyxPQUFPLENBQUM7WUFDN0MsTUFBTUMsZUFBZUYsYUFBYUMsT0FBTyxDQUFDO1lBQzFDLE1BQU1FLGtCQUFrQkgsYUFBYUMsT0FBTyxDQUFDO1lBQzdDLE1BQU1HLHVCQUF1QkosYUFBYUMsT0FBTyxDQUFDO1lBRWxELElBQUlGLGlCQUFpQjtnQkFDbkJaLGNBQWNrQixLQUFLQyxLQUFLLENBQUNQO1lBQzNCLE9BQU87Z0JBQ0wscUNBQXFDO2dCQUNyQyxNQUFNUSxvQkFBb0J2QixtQkFBbUJ3QixHQUFHO2tFQUFDLENBQUNDLE9BQVU7NEJBQzFEQTs0QkFDQUMsY0FBYzt3QkFDaEI7O2dCQUNBdkIsY0FBY29CO1lBQ2hCO1lBRUEsSUFBSUwsY0FBYztnQkFDaEIsTUFBTVMsZ0JBQWdCTixLQUFLQyxL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QUFTO29CQUFDLElBQUlEO1lBQ3ZHLE9BQU87Z0JBQ0wscUJBQXFCO2dCQUNyQixPQUFPO3VCQUFJeEI7b0JBQU07d0JBQUVvQjt3QkFBUUM7d0JBQU1JLFdBQVc7b0JBQUs7aUJBQUU7WUFDckQ7UUFDRjtJQUNGO0lBRUEsTUFBTUMsb0JBQW9CLENBQUNOLFFBQWdCQztRQUN6QyxNQUFNTSxhQUFhckQsZ0JBQWdCaUQsSUFBSSxDQUFDLENBQUNDLElBQU1BLEVBQUVKLE1BQU0sS0FBS0EsVUFBVUksRUFBRUgsSUFBSSxLQUFLQTtZQUMxRU07UUFBUCxPQUFPQSxDQUFBQSx3QkFBQUEsdUJBQUFBLGlDQUFBQSxXQUFZRixTQUFTLGNBQXJCRSxtQ0FBQUEsd0JBQXlCO0lBQ2xDO0lBRUEsT0FBTztRQUNML0Q7UUFDQUU7UUFDQUU7UUFDQUk7UUFDQUU7UUFDQTZCO1FBQ0FJO1FBQ0FPO1FBQ0FDO1FBQ0FJO1FBQ0FPO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUvbHVjYXMvbHVjYXMvdGltZS10cmFja2VyL3NyYy9ob29rcy91c2UtdGltZS10cmFja2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWhvb2tzL3NldC1zdGF0ZS1pbi1lZmZlY3QgKi9cbid1c2UgY2xpZW50J1xuXG5pbXBvcnQgdHlwZSB7IEFjdGl2aXR5LCBEYWlseVRvZG8sIERhaWx5VG9kb0NvbXBsZXRpb24sIFNlc3Npb24gfSBmcm9tICdAL3R5cGVzL2FjdGl2aXR5J1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXG5cbmNvbnN0IERFRkFVTFRfQUNUSVZJVElFUzogc3RyaW5nW10gPSBbXVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVGltZVRyYWNrZXIoKSB7XG4gIGNvbnN0IFthY3Rpdml0aWVzLCBzZXRBY3Rpdml0aWVzXSA9IHVzZVN0YXRlPEFjdGl2aXR5W10+KFtdKVxuICBjb25zdCBbYWN0aXZlQWN0aXZpdHksIHNldEFjdGl2ZUFjdGl2aXR5XSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpXG4gIGNvbnN0IFtzZXNzaW9uSGlzdG9yeSwgc2V0U2Vzc2lvbkhpc3RvcnldID0gdXNlU3RhdGU8U2Vzc2lvbltdPihbXSlcbiAgY29uc3QgW3Nlc3Npb25TdGFydFRpbWUsIHNldFNlc3Npb25TdGFydFRpbWVdID0gdXNlU3RhdGU8RGF0ZSB8IG51bGw+KG51bGwpXG4gIGNvbnN0IFtkYWlseVRvZG9zLCBzZXREYWlseVRvZG9zXSA9IHVzZVN0YXRlPERhaWx5VG9kb1tdPihbXSlcbiAgY29uc3QgW3RvZG9Db21wbGV0aW9ucywgc2V0VG9kb0NvbXBsZXRpb25zXSA9IHVzZVN0YXRlPERhaWx5VG9kb0NvbXBsZXRpb25bXT4oW10pXG4gIGNvbnN0IGludGVydmFsUmVmID0gdXNlUmVmPE5vZGVKUy5UaW1lb3V0IHwgbnVsbD4obnVsbClcblxuICAvLyBMb2FkIGRhdGEgZnJvbSBsb2NhbFN0b3JhZ2Ugb24gbW91bnRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzYXZlZEFjdGl2aXRpZXMgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYWN0aXZpdGllcycpXG4gICAgY29uc3Qgc2F2ZWRIaXN0b3J5ID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3Nlc3Npb25IaXN0b3J5JylcbiAgICBjb25zdCBzYXZlZERhaWx5VG9kb3MgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZGFpbHlUb2RvcycpXG4gICAgY29uc3Qgc2F2ZWRUb2RvQ29tcGxldGlvbnMgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9kb0NvbXBsZXRpb25zJylcblxuICAgIGlmIChzYXZlZEFjdGl2aXRpZXMpIHtcbiAgICAgIHNldEFjdGl2aXRpZXMoSlNPTi5wYXJzZShzYXZlZEFjdGl2aXRpZXMpKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbml0aWFsaXplIHdpdGggZGVmYXVsdCBhY3Rpdml0aWVzXG4gICAgICBjb25zdCBkZWZhdWx0QWN0aXZpdGllcyA9IERFRkFVTFRfQUNUSVZJVElFUy5tYXAoKG5hbWUpID0+ICh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHRvdGFsU2Vjb25kczogMCxcbiAgICAgIH0pKVxuICAgICAgc2V0QWN0aXZpdGllcyhkZWZhdWx0QWN0aXZpdGllcylcbiAgICB9XG5cbiAgICBpZiAoc2F2ZWRIaXN0b3J5KSB7XG4gICAgICBjb25zdCBwYXJzZWRIaXN0b3J5ID0gSlNPTi5wYXJzZShzYXZlZEhpc3RvcnkpXG4gICAgICAvLyBDb252ZXJ0IGRhdGUgc3RyaW5ncyBiYWNrIHRvIERhdGUgb2JqZWN0c1xuICAgICAgY29uc3QgaGlzdG9yeVdpdGhEYXRlcyA9IHBhcnNlZEhpc3RvcnkubWFwKChzZXNzaW9uOiBhbnkpID0+ICh7XG4gICAgICAgIC4uLnNlc3Npb24sXG4gICAgICAgIHN0YXJ0VGltZTogbmV3IERhdGUoc2Vzc2lvbi5zdGFydFRpbWUpLFxuICAgICAgICBlbmRUaW1lOiBuZXcgRGF0ZShzZXNzaW9uLmVuZFRpbWUpLFxuICAgICAgfSkpXG4gICAgICBzZXRTZXNzaW9uSGlzdG9yeShoaXN0b3J5V2l0aERhdGVzKVxuICAgIH1cblxuICAgIGlmIChzYXZlZERhaWx5VG9kb3MpIHtcbiAgICAgIHNldERhaWx5VG9kb3MoSlNPTi5wYXJzZShzYXZlZERhaWx5VG9kb3MpKVxuICAgIH1cblxuICAgIGlmIChzYXZlZFRvZG9Db21wbGV0aW9ucykge1xuICAgICAgc2V0VG9kb0NvbXBsZXRpb25zKEpTT04ucGFyc2Uoc2F2ZWRUb2RvQ29tcGxldGlvbnMpKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgLy8gU2F2ZSBhY3Rpdml0aWVzIHRvIGxvY2FsU3RvcmFnZSB3aGVuZXZlciB0aGV5IGNoYW5nZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChhY3Rpdml0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhY3Rpdml0aWVzJywgSlNPTi5zdHJpbmdpZnkoYWN0aXZpdGllcykpXG4gICAgfVxuICB9LCBbYWN0aXZpdGllc10pXG5cbiAgLy8gU2F2ZSBzZXNzaW9uIGhpc3RvcnkgdG8gbG9jYWxTdG9yYWdlIHdoZW5ldmVyIGl0IGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc2Vzc2lvbkhpc3RvcnkubGVuZ3RoID4gMCkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3Nlc3Npb25IaXN0b3J5JywgSlNPTi5zdHJpbmdpZnkoc2Vzc2lvbkhpc3RvcnkpKVxuICAgIH1cbiAgfSwgW3Nlc3Npb25IaXN0b3J5XSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdkYWlseVRvZG9zJywgSlNPTi5zdHJpbmdpZnkoZGFpbHlUb2RvcykpXG4gIH0sIFtkYWlseVRvZG9zXSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd0b2RvQ29tcGxldGlvbnMnLCBKU09OLnN0cmluZ2lmeSh0b2RvQ29tcGxldGlvbnMpKVxuICB9LCBbdG9kb0NvbXBsZXRpb25zXSlcblxuICAvLyBUaW1lciBlZmZlY3RcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYWN0aXZlQWN0aXZpdHkpIHtcbiAgICAgIGludGVydmFsUmVmLmN1cnJlbnQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIHNldEFjdGl2aXRpZXMoKHByZXYpID0+XG4gICAgICAgICAgcHJldi5tYXAoKGFjdGl2aXR5KSA9PlxuICAgICAgICAgICAgYWN0aXZpdHkubmFtZSA9PT0gYWN0aXZlQWN0aXZpdHkgPyB7IC4uLmFjdGl2aXR5LCB0b3RhbFNlY29uZHM6IGFjdGl2aXR5LnRvdGFsU2Vjb25kcyArIDEgfSA6IGFjdGl2aXR5LFxuICAgICAgICAgICksXG4gICAgICAgIClcbiAgICAgIH0sIDEwMDApXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpbnRlcnZhbFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxSZWYuY3VycmVudClcbiAgICAgICAgaW50ZXJ2YWxSZWYuY3VycmVudCA9IG51bGxcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGludGVydmFsUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbFJlZi5jdXJyZW50KVxuICAgICAgfVxuICAgIH1cbiAgfSwgW2FjdGl2ZUFjdGl2aXR5XSlcblxuICBjb25zdCBhZGRBY3Rpdml0eSA9IChuYW1lOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoYWN0aXZpdGllcy5zb21lKChhY3Rpdml0eSkgPT4gYWN0aXZpdHkubmFtZSA9PT0gbmFtZSkpIHtcbiAgICAgIGFsZXJ0KCdBY3Rpdml0eSBhbHJlYWR5IGV4aXN0cyEnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgbmV3QWN0aXZpdHk6IEFjdGl2aXR5ID0ge1xuICAgICAgbmFtZSxcbiAgICAgIHRvdGFsU2Vjb25kczogMCxcbiAgICB9XG5cbiAgICBzZXRBY3Rpdml0aWVzKChwcmV2KSA9PiBbLi4ucHJldiwgbmV3QWN0aXZpdHldKVxuICB9XG5cbiAgY29uc3Qgc3RhcnRBY3Rpdml0eSA9IChuYW1lOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXG5cbiAgICAvLyBJZiB0aGVyZSdzIGFuIGFjdGl2ZSBhY3Rpdml0eSwgc3RvcCBpdCBhbmQgY3JlYXRlIGEgc2Vzc2lvblxuICAgIGlmIChhY3RpdmVBY3Rpdml0eSAmJiBzZXNzaW9uU3RhcnRUaW1lKSB7XG4gICAgICBjb25zdCBzZXNzaW9uOiBTZXNzaW9uID0ge1xuICAgICAgICBhY3Rpdml0eU5hbWU6IGFjdGl2ZUFjdGl2aXR5LFxuICAgICAgICBzdGFydFRpbWU6IHNlc3Npb25TdGFydFRpbWUsXG4gICAgICAgIGVuZFRpbWU6IG5vdyxcbiAgICAgICAgZHVyYXRpb25TZWNvbmRzOiBNYXRoLmZsb29yKChub3cuZ2V0VGltZSgpIC0gc2Vzc2lvblN0YXJ0VGltZS5nZXRUaW1lKCkpIC8gMTAwMCksXG4gICAgICB9XG4gICAgICBzZXRTZXNzaW9uSGlzdG9yeSgocHJldikgPT4gW3Nlc3Npb24sIC4uLnByZXZdKVxuICAgIH1cblxuICAgIC8vIElmIGNsaWNraW5nIHRoZSBzYW1lIGFjdGl2aXR5LCBzdG9wIGl0XG4gICAgaWYgKGFjdGl2ZUFjdGl2aXR5ID09PSBuYW1lKSB7XG4gICAgICBzZXRBY3RpdmVBY3Rpdml0eShudWxsKVxuICAgICAgc2V0U2Vzc2lvblN0YXJ0VGltZShudWxsKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGFydCB0aGUgbmV3IGFjdGl2aXR5XG4gICAgICBzZXRBY3RpdmVBY3Rpdml0eShuYW1lKVxuICAgICAgc2V0U2Vzc2lvblN0YXJ0VGltZShub3cpXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3RvcEFjdGl2aXR5ID0gKCkgPT4ge1xuICAgIGlmIChhY3RpdmVBY3Rpdml0eSAmJiBzZXNzaW9uU3RhcnRUaW1lKSB7XG4gICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXG4gICAgICBjb25zdCBzZXNzaW9uOiBTZXNzaW9uID0ge1xuICAgICAgICBhY3Rpdml0eU5hbWU6IGFjdGl2ZUFjdGl2aXR5LFxuICAgICAgICBzdGFydFRpbWU6IHNlc3Npb25TdGFydFRpbWUsXG4gICAgICAgIGVuZFRpbWU6IG5vdyxcbiAgICAgICAgZHVyYXRpb25TZWNvbmRzOiBNYXRoLmZsb29yKChub3cuZ2V0VGltZSgpIC0gc2Vzc2lvblN0YXJ0VGltZS5nZXRUaW1lKCkpIC8gMTAwMCksXG4gICAgICB9XG4gICAgICBzZXRTZXNzaW9uSGlzdG9yeSgocHJldikgPT4gW3Nlc3Npb24sIC4uLnByZXZdKVxuICAgIH1cblxuICAgIHNldEFjdGl2ZUFjdGl2aXR5KG51bGwpXG4gICAgc2V0U2Vzc2lvblN0YXJ0VGltZShudWxsKVxuICB9XG5cbiAgY29uc3QgYWRkRGFpbHlUb2RvID0gKG5hbWU6IHN0cmluZykgPT4ge1xuICAgIGlmIChkYWlseVRvZG9zLnNvbWUoKHRvZG8pID0+IHRvZG8ubmFtZSA9PT0gbmFtZSkpIHtcbiAgICAgIGFsZXJ0KCdUb2RvIGFscmVhZHkgZXhpc3RzIScpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBuZXdUb2RvOiBEYWlseVRvZG8gPSB7XG4gICAgICBpZDogYHRvZG8tJHtEYXRlLm5vdygpfWAsXG4gICAgICBuYW1lLFxuICAgIH1cblxuICAgIHNldERhaWx5VG9kb3MoKHByZXYpID0+IFsuLi5wcmV2LCBuZXdUb2RvXSlcbiAgfVxuXG4gIGNvbnN0IHRvZ2dsZVRvZG9Db21wbGV0aW9uID0gKHRvZG9JZDogc3RyaW5nLCBkYXRlOiBzdHJpbmcpID0+IHtcbiAgICBzZXRUb2RvQ29tcGxldGlvbnMoKHByZXYpID0+IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gcHJldi5maW5kKChjKSA9PiBjLnRvZG9JZCA9PT0gdG9kb0lkICYmIGMuZGF0ZSA9PT0gZGF0ZSlcblxuICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgIC8vIFRvZ2dsZSBleGlzdGluZyBjb21wbGV0aW9uXG4gICAgICAgIHJldHVybiBwcmV2Lm1hcCgoYykgPT4gKGMudG9kb0lkID09PSB0b2RvSWQgJiYgYy5kYXRlID09PSBkYXRlID8geyAuLi5jLCBjb21wbGV0ZWQ6ICFjLmNvbXBsZXRlZCB9IDogYykpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBZGQgbmV3IGNvbXBsZXRpb25cbiAgICAgICAgcmV0dXJuIFsuLi5wcmV2LCB7IHRvZG9JZCwgZGF0ZSwgY29tcGxldGVkOiB0cnVlIH1dXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IGdldFRvZG9Db21wbGV0aW9uID0gKHRvZG9JZDogc3RyaW5nLCBkYXRlOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICBjb25zdCBjb21wbGV0aW9uID0gdG9kb0NvbXBsZXRpb25zLmZpbmQoKGMpID0+IGMudG9kb0lkID09PSB0b2RvSWQgJiYgYy5kYXRlID09PSBkYXRlKVxuICAgIHJldHVybiBjb21wbGV0aW9uPy5jb21wbGV0ZWQgPz8gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWN0aXZpdGllcyxcbiAgICBhY3RpdmVBY3Rpdml0eSxcbiAgICBzZXNzaW9uSGlzdG9yeSxcbiAgICBkYWlseVRvZG9zLFxuICAgIHRvZG9Db21wbGV0aW9ucyxcbiAgICBhZGRBY3Rpdml0eSxcbiAgICBzdGFydEFjdGl2aXR5LFxuICAgIHN0b3BBY3Rpdml0eSxcbiAgICBhZGREYWlseVRvZG8sXG4gICAgdG9nZ2xlVG9kb0NvbXBsZXRpb24sXG4gICAgZ2V0VG9kb0NvbXBsZXRpb24sXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsIkRFRkFVTFRfQUNUSVZJVElFUyIsInVzZVRpbWVUcmFja2VyIiwiYWN0aXZpdGllcyIsInNldEFjdGl2aXRpZXMiLCJhY3RpdmVBY3Rpdml0eSIsInNldEFjdGl2ZUFjdGl2aXR5Iiwic2Vzc2lvbkhpc3RvcnkiLCJzZXRTZXNzaW9uSGlzdG9yeSIsInNlc3Npb25TdGFydFRpbWUiLCJzZXRTZXNzaW9uU3RhcnRUaW1lIiwiZGFpbHlUb2RvcyIsInNldERhaWx5VG9kb3MiLCJ0b2RvQ29tcGxldGlvbnMiLCJzZXRUb2RvQ29tcGxldGlvbnMiLCJpbnRlcnZhbFJlZiIsInNhdmVkQWN0aXZpdGllcyIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJzYXZlZEhpc3RvcnkiLCJzYXZlZERhaWx5VG9kb3MiLCJzYXZlZFRvZG9Db21wbGV0aW9ucyIsIkpTT04iLCJwYXJzZSIsImRlZmF1bHRBY3Rpdml0aWVzIiwibWFwIiwibmFtZSIsInRvdGFsU2Vjb25kcyIsInBhcnNlZEhpc3RvcnkiLCJoaXN0b3J5V2l0aERhdGVzIiwic2Vzc2lvbiIsInN0YXJ0VGltZSIsIkRhdGUiLCJlbmRUaW1lIiwibGVuZ3RoIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImN1cnJlbnQiLCJzZXRJbnRlcnZhbCIsInByZXYiLCJhY3Rpdml0eSIsImNsZWFySW50ZXJ2YWwiLCJhZGRBY3Rpdml0eSIsInNvbWUiLCJhbGVydCIsIm5ld0FjdGl2aXR5Iiwic3RhcnRBY3Rpdml0eSIsIm5vdyIsImFjdGl2aXR5TmFtZSIsImR1cmF0aW9uU2Vjb25kcyIsIk1hdGgiLCJmbG9vciIsImdldFRpbWUiLCJzdG9wQWN0aXZpdHkiLCJhZGREYWlseVRvZG8iLCJ0b2RvIiwibmV3VG9kbyIsImlkIiwidG9nZ2xlVG9kb0NvbXBsZXRpb24iLCJ0b2RvSWQiLCJkYXRlIiwiZXhpc3RpbmciLCJmaW5kIiwiYyIsImNvbXBsZXRlZCIsImdldFRvZG9Db21wbGV0aW9uIiwiY29tcGxldGlvbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/use-time-tracker.ts\n"));

/***/ })

});